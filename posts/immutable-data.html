<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>czyzykowski.com - Immutable data</title>

        <link rel="shortcut icon" href="../images/favicon.ico">
        <link rel="stylesheet" href="../css/uikit.min.css">
        <link rel="stylesheet" href="../css/syntax.css">
    </head>
    <body>
        <div class="uk-container uk-width-xxlarge">
            <hr class="uk-margin-xlarge-top" />
            <nav class="uk-position-small uk-position-fixed uk-position-right">
                
                  <a class="uk-margin-right" href="../">Home</a>
                
                <a class="uk-margin-right" href="../about.html">About</a>
                <a class="uk-margin-right" href="https://twitter.com/czyzykowski">Twitter</a>
            </nav>

            <article class="uk-article">

    <h1 class="uk-article-title">Immutable data</h1>
    
        <p class="uk-text-lead uk-text-muted">Not that uncommon and very helpful</p>
    

		<section id="post-body">
            <p>Immutable data known also by the name of persistent data is becoming mainstream. It’s another approach first used in functional programming.</p>
<p>The whole idea is that once you create a given piece of data you cannot change it. It persists in that state.</p>
<p>At first sight, it would seem it’s impossible to build anything useful which such approach. How can you store any data if you cannot change the data structures you already have. The task seems to be impossible.</p>
<p>It’s not as hard as it seems. That approach to data is actually common in the programming languages. But usually, the scope of immutable data is limited.</p>
<p>In all languages, I know at least numbers are immutable. You cannot change the value of 5 to be 6. The only thing you can do is to get new value and store that.</p>
<p>In some languages, the idea of immutability extends to strings. That makes any operation on them creating a new string. That fact, in the most part, does not cause any problems.</p>
<p>The idea of immutable data extends that notion of value to common data structures. Things like arrays (lists), maps (hashes/objects) and sets become the same kind of thing as a number. They become values.</p>
<p>You can’t change anything.</p>
<p>For example to get a list with a new element in it you need to create a new list. It will contain everything from the previous one plus your new element. The old list stays the same as before and now you have an instance with what you wanted.</p>
<p>The same approach happens with maps and sets. Create new thing based on the old but with your modifications applied.</p>
<p>You may think that this must be horribly inefficient. To copy all those items around. Will building 100 item list require 99 copies of elements 1–99? That’s a lot of memory used just for the sake of immutability.</p>
<p>Fortunately, it doesn’t have to be that way.</p>
<p>Given the constraint of not immutability, the common parts of any data structure can be shared between all the copies. Smart algorithms and techniques can make it so only one copy of every single item is stored in memory.</p>
<p>It’s also possible to speed up a lot of common access patterns because the layout in memory may be optimized for that instead for easy extensibility.</p>
<p>In some cases, the memory usage can even go down because it’s being used in a smarter way. In places where several code paths are initialized with the same copy of a given data structure, there’s no need to make a special copy. Because of immutability, those code paths will not step on each other’s toes.</p>
<p>Which brings me to the biggest advantage of using immutable data. It’s much easier to reason about it. Once you have a reference to something you know that no other code path can change it. Your copy will stay the same for as long as you have it. That eliminates a certain class of bugs. Bugs which are usually hard to track because the problem is in a different part of the code than its manifestation.</p>
<p>In conclusion: immutable data can make your program faster and take less memory but what’s the most important is that it will make it much easier to reason about it. Any data modification is visible because one needs to swap out reference to the modified version.</p>
		</section>

		<footer id="post-meta" class="clearfix">
      <hr />
      <div class="uk-grid">
        <p class="uk-article-meta uk-width-1-2">
          <span>Posted on</span> February 26
        </p>

        <p class="uk-article-meta uk-width-1-2 uk-text-right">
          <span>Written by</span> Łukasz Czyżykowski
        </p>
      </div>

      <div class="uk-text-center">
        <a class="uk-icon-button" href="https://twitter.com/share">
          <img src="../images/twitter.svg" width="16" height="16" alt="twitter icon" />
        </a>

        <a class="uk-icon-button" href="#" onclick="
            window.open(
              'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
              'facebook-share-dialog',
              'width=626,height=436');
            return false;">

          <img src="../images/facebook.svg" width="16" height="16" alt="facebook icon" />
        </a>
      </div>
		</footer>
	</article>

</section>


        </div>

        <script>
          if (window.location.hostname === 'czyzykowski.com') {
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-4012543-11', 'auto');
            ga('send', 'pageview');
          }
        </script>
    </body>
</html>
